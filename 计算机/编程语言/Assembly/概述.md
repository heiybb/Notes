8086寄存器
  AX（通用寄存器）：累加寄存器，常用于运算与转存数据
	BX（通用寄存器）：转存数据，（计数存储器——内存偏移位置寻址）CX（通用寄存器）：转存数据，（存储默认循环次数）
	DX（通用寄存器）：转存数据
	CS（段寄存器）：实时指令段寄存器
	DS（段寄存器）：
		默认段寄存器（For BX、SI、DI）（不能通过内存及常量寻址方式更改DS中的值，只能通过寄存器寻址方式）
	ES（段寄存器）
	SS（段寄存器）：默认栈顶段寄存器
	GS（段寄存器）：视频段寄存器
	DI：
	SI：
	BP：用于存储栈偏移位，从而用来寻址栈中元素
	IP：存储实时指令偏移地址
	SP：存储实时栈顶偏移地址
	CS:IP：表示实时指令全地址
	SS:SP：内存中实时栈顶地址




内存寻址方式的时候需要在内存地址（里面只写入偏移地址——段地址为默认，即DS）上加上方括号

数据高2位在高地址上，低2位在低地址上
指令相同不代表翻译成机器代码就一定相同，还要根据操作数决定
当修改SS寄存器的内容时，Debug中的t命令也会执行下一条命令（中断机制）
——造成栈空间的数据改变



loop：循环命令

start  程序入口
and 与操作
or 或操作
dup 配合声明符号定义循环数据（数组）
int 中断——非常有用（00h——除数为0   10h——显示信息）
%include "~.inc"  类似于C，包含文件


在8086处理器中，汇编语言的源代码中不加后缀的数据默认为
汇编源程序与debug汇编程序使用时是不同的，




伪命令（由编译器标识的命令）：
assume cs:codesg  定义codesg这个段（向操作系统申请这个段空间），并且与cs寄存器相关联（只是标识而已），（这条命令是由编译器执行的，所以可能由一系列的复杂源组成，就相当于封装了一些数据）
段名 segment  
..
段名 end     段的框架，一个汇编程序可以有多个段




修饰符：
没有修饰符时，根据修改寄存器的大小控制数据长度
word ptr  字修饰符
dword ptr  双字修饰符
byte ptr 字符修饰符





nasm语法：
nasm源文件中，字符均被看为地址（用[]包含的不算）
结构数组宏定义：
%macro  定义的宏名  参数数
~~~~~~（假定n个参数，则用%i表示第i个参数，编译时，就将参数带入得到一个结构数组对象）
%endmacro

& 与运算
| 或运算
equ 代替语句（同=意义，但并未开辟空间）












采用二进制补码的形式表示带符号数，最高位表示符号，其中0代表正，1代表负

求补就是求相反（表示）数

什么都不加时，默认是10进制数据，因此最好加后缀

org：不对应指令码，即严格意义上不是汇编，它的作用是在链接时显现的，用来将接下来的一句话放到指定的绝对地址

[section ]：用来表示代码段功能，相当于注释，不会被编译

$：当前地址位
$$：当前段的首地址

rep:命令同loop

org：链接时执行（不进行编译），当程序执行时把程序加载到对应的内存地址

db：在当前位置写入数据，按字节写入，小整数只存储1个字节，当后面接字符串时，每个字符占一个字节
dw：当前位置写入一个字（x86实模式是双字节）
dd：当前位置写入一个双字（x86实模式是4字节）
times：重复操作，后面接次数


xor：异或，11得0，00得0

		
cmp 减法操作，但不保存结果，仅用来影响标志位，等于0时执行下一语句
test ax,bx：将ax与bx进行与运算，但不保存结果，只影响标志位




