关于signed/unsigned，实际上这两个概念只是形式上，本质（存储）是一样的，而在运算的时候，则是先将补码转换为原码进行计算，然后再转换为补码。这里就有个问题——变量开头为1时，把变量当作负数（signed）和正数（unsigned）计算的结果会不一样，什么情况下需要考虑这种问题呢——强制转换的时候（signed与unsigned混合运算时），如下例子

unsigned int a=1; int b=-2; 则a+b>0，我们想的是1-2=-1<0，但实际上a为unsigned，b为signed，为保证不损失信息（这是强制转换的原则——在可行条件下），系统把b当作unsigned计算得到一个unsigned值，虽然得到的结果存储信息始终为0xffffffff(可表示-1也可表示超大正整数)，但这里是当作unsigned处理的

char、unsigned char、signed char实际上是不同的，即可大胆猜测变量名字中一般还带有变量的类型信息（从而确定这些变量支持的运算等），至于如何实现暂且不管（可能是在编译器对每个数据进行类型检查）


大端小端的问题

定点浮点概念及存储相关知识（IEEE754）
定点数分定点整数和定点小数，原理是均只进行整数运算，定点整数运算就等同于int计算，而定点小数运算一般在单片机（DSP等）才有（因为单片机不需要太大数据计算量，且性能有限，浮点运算就没多少重要了）。比如对16位数，1位符号位，3位整数位，12位小数位（定点就没必要记录小数点），2.5的存储位表示为0010 1000 0000 0000，2.5*2.5就是2.5*2^12*2.5*2^12然后再除2^12得到值存储，但表示的值还要再除以2^12
数组与指针的区别
int a[3];
printf("%p,%p",(int *)(&a+1),(&a[0]+1));
如果数组名和指针“完全一样”，那么上面的输出值两个地址就是一样的，实际上不是，若后面的地址为10，则前面的地址为10+4*3=1C，显然这里的取地址带有数组的长度信息，所以指针+1实际上是以该指针指向数据类型的长度进行“内存对齐+1”，而“数组名是整个数组的代名词——它可以当指针使用，但它并不同于指针”


纯指针的下标可以为负数


柔性数组：在结构体的最后面（前面必须有变量）可定义一个可变长度的数组，但是这个数组不计入结构体的长度，至于其具体长度在使用的时候用动态内存（malloc等）生成，生成的长度减去结构体前面变量的长度就是数组的长度







sizeof(enum_name)=4
枚举类型同union一样，限定范围，每次只能取其中一个，所以其sizeof是其中元素最大的所占位，但由于恒为int，所以恒为4


内存对齐
内存对齐指的是关于内存值的对齐（数据存放的首地址和当前对齐参数是整除关系），分两步对齐，先是成员数据对齐（在组织成员的时候——如结构体），再是整数对齐，其中对特定编译器有一个对齐系数（可以通过#pragma pack(n)设置为n，n取2的整数次幂）
内存对齐的作用


野指针：指针指向的动态内存被释放后，没有将指针赋为NULL
