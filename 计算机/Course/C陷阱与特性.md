---
title: C陷阱和特性
layout: post
tag: [C]
---

这篇文章会尽量列举C语言的特性和易错点，有些内容可能直接来自于其它书籍（如C陷阱和缺陷、C专家编程等），如果你想快速了解C语言的基础，可以看这篇[文章](C语言基础参考手册)



## 词法分析的『贪心法』

原则：尽可能多的读取多的字符作为一个组合，如果正在读取的字符可以和当前字符组组成一个组合，那就将这个字符加入当前字符组，然后继续读入，直到不能组成组合，就清空当前字符组，重新开始

看下面的例子

```
a---b    // 等同于(a--)-b，自减最后算

y/*p    // /*作为注释的开始

*p++ = val;  //将val进行压栈

val = *--p;  //将val弹出栈
```

## 指针

空指针不等于空字符串

函数名在使用就是指向函数开头的指针，&函数名==函数名

## (\*(void (\*)())0)()——类型转换

void (\*h)()表示声明一个指向void函数的指针h，则void (\*)()用于声明变量，(\*(void (\*)())0)()表示调用内存0处的函数


C语言是强类型语言


测试这个声明单元(void (\*)())无用？声明单元和强制类型转换的关系是怎样的？

递归下降分析程序？

分析下面这些奇葩？
char \*argv[]    //这个只能用在函数声明的参数中，表示只想字符数组的指针
int (\*daytab)[13]
int \*daytab[13]
void (\*comp)()
char (\*(\*x())[])()
char (\*(\*x[3])())[5]


不过除了IOCCC的选手，应该没多少人会在项目中写这样的代码吧



## 优先级

从右向左和从左向右结合的区别？


## switch

```
switch (color){
  case 1: printf("red");
  case 2: printf("black");
  case 3: printf("blue");
}
```

如果color值为2，得到的结果为blackblue


## sizeof

sizeof不是一个函数，字节数的计算在程序编译时进行，通过下面这个例子可以证明这一点

```
// test.c

#include <stdio.h>

int main(){
  int a = sizeof 1;
  return 0;
}
```

```
;编译但不链接test.c文件
> gcc -c test.c -o test.o

;反汇编查看test.o
> objdump -d test.o

00000000 <main>:
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp
   6:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%ebp)
   d:	b8 00 00 00 00       	mov    $0x0,%eax
  12:	c9                   	leave  
  13:	c3                   	ret

```

为避免麻烦，使用sizeof最好加上括号

根据sizeof我们可以引出指针和数组的不同，当a分别为10字节字符数组和字符串指针时，sizeof(a)分别返回10和4，也就是数组名并不是纯粹意义上的指针，数组是C语言必不可少的内建类型。

对数组只有两种特殊操作——得到数组的大小和确定数组各位置的指针，而其它所有操作都可以转换为对应的指针操作。




## const与指针传递类型

```
指向非常量数据的非常量指针：char \*str
指向非常量数据的常量指针：char \*const str
指向常量数据的非常量指针：const char \*str
指向常量数据的常量指针：const char \*const str
```






## 标准中产生的问题

C99之前的C变量的声明必须在开头

关于int main，void main的问题

关键字const、signed、volatile是ANSI标准中新增加的，enum和void是第一版C后ANSI之前新增加的，entry曾经被保留为关键字，但现在已不是了。


## 边界问题

```
while (i<n){
	b[i++] = a[i];
}
```

上述代码其实理论上并没错，不过和软件工程的思想违背，所以最好不要那么写，实际上，最好不要用++

## 求值顺序

和求值顺序有关的只有四个运算符，分别是&&、||、,、?:

&&  先算左边，左边为True时算右边
||  先算左边，左边为False时算右边
,   先算左边，算完后扔掉再算右边
?:  先算最前面，True就算中间，False就算后面








## 参数传递

无论是实参还是形参传递其值都是采用中间变量存储，实参没什么好证明的，直接证明形参（还是通过objdump反编译查看）

```
;代码
#include <stdio.h>

void test(int a){}

int main(){
  int a = 2;
  test(a);
  return 0;
}


;反编译代码
080483b4 <test>:
 80483b4:	55                   	push   %ebp
 80483b5:	89 e5                	mov    %esp,%ebp
 80483b7:	5d                   	pop    %ebp
 80483b8:	c3                   	ret

080483b9 <main>:
 80483b9:	55                   	push   %ebp
 80483ba:	89 e5                	mov    %esp,%ebp
 80483bc:	83 ec 14             	sub    $0x14,%esp
 80483bf:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
 80483c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80483c9:	89 04 24             	mov    %eax,(%esp)
 80483cc:	e8 e3 ff ff ff       	call   80483b4 <test>
 80483d1:	b8 00 00 00 00       	mov    $0x0,%eax
 80483d6:	c9                   	leave  
 80483d7:	c3                   	ret  
```

查看反编译代码，80483bf用于赋值a（在C语言程序中a是放在栈中的，关于C内存详情，后面有讲），80483c6用于把a的值传到eax寄存器，80483c9用于将eax中的值传到esp的内存区域（这就是在生成变量副本，为调用函数做准备），80483cc则显然是在调用函数



## int argc, char \*argv[]

用于程序开始执行时的参数传入，argc表示参数个数，argv表示字符串数组，每个字符串算一个参数，调用程序时的程序名始终作为第一个参数






## define宏

\#define 名字（格式要求同变量名） 替换文本

预处理并会保留空格、换行符，但注释、制表符等会被替换删除

define在预处理的时候进行替换

define是如何当『函数』用的？虽然它不是函数

## asert


## 声明有没有分配内存，指针在内存中分配了内存

局部变量存储在栈中
动态申请的存储在堆中
字符串常量存储在静态存储区
初始化的全局变量、静态变量存储在静态存储区
未初始化的全局变量、静态变量存储在BSS区


## 词法规则

6类单词：标识符、关键字、常量、字符串字面值、运算符、其它分隔符

空格、横向/纵向制表符、换行符、换页符、注解（合称为空白符）被略过



## \_\_typeof\_\_     \_\_extension\_\_    \_\_auto\_type

gcc在标准上增加的扩展，\_\_typeof\_\_用来声明，\_\_extension\_\_则用于基于标准编译时不报错

```
typeof(x) y;  //基本形式，即声明一个x类型的y，动态定义，运行时完成


#define max(a,b) \
  ({ typeof (a) _a = (a); \
      typeof (b) _b = (b); \
    _a > _b ? _a : _b; })

#define MAX(x,y) ((x) > (y)? (x): (y))


```

上面两个define实际上功能一样，上面那样定义主要是可以避免计算多次



## side effect



## 预定义符号

\_\_FILE\_\_
\_\_LINE\_\_
\_\_DATE\_\_
\_\_TIME\_\_
\_\_STDC\_\_

\#define
\#undef
\#if \#elif \#else \#endif
\#ifdef \#endif
\#line
\#error
\#pragma
\#argument



## /\*/\*/0\*/\*\*/1

ANSI标准C是不支持注释嵌套的，但有的编译器在实现的时候还是支持的

支持嵌套的时候：贪心法[1~2]作为单运算符，[3~4]继续作单运算符——匹配[7~8]，则/0作为注释内容，[10~11]匹配[1~2]，则*作为注释内容，结果为1

不支持嵌套的时候：贪心法[1~2]作为单运算符，此时后面出现的/\*均不算数（直到第一个\*/结束），则[3]作为单运算符，[4~5]由贪心法作为单运算符匹配[1~2]，此时/作为注释内容，而后0*是未注释部分，[8~9]作为新注释匹配[10~11]，1未注释，则去掉注释内容后结果为0\*1=0


## 括号

圆括号：圆括号代表最高优先级的运算符，一个圆括号内的表达式无论多么复杂，其最终只返回一个数据

花括号：花括号代表一个代码区块，是一个作用域


## 未定义行为
