1、进程特性
	动态性：
	并发性：
	独立性：
	异步性：

9、进程状态
	就绪（基本态）：所需要的资源都准备好了，只需要等待操作系统的调度
	阻塞（基本态）：因I/O等阻断，需要一个条件去解除阻塞
	运行（基本态）：此时正在使用CPU的进程
	挂起（常用态）

12、进程互斥及同步的实现

死锁和饥饿
	饥饿：
		进程长时间得不到资源，但导致饥饿的不止死锁，还包括长时间的高优先级进程剥夺等，所以饥饿描述的是单进程状态
	死锁：
		当几个进程同时请求各自的资源，但各自需要的资源刚好被别的进程占用，且每个进程在未得到需要的资源前不释放已占用的资源，这样这几个进程就行成了死锁，永远处于阻塞状态，所以死锁描述的是几个进程达到的一种状态

产生死锁的必要条件（同时达到）：
	互斥：资源只能被一个进程占用
	不剥夺：在进程不主动释放资源的情况下不剥夺进程的资源
	保持请求：
	循环等待：

预防死锁







4、全局描述符表（GDT）

	全局描述符表：每个描述符8字节，用来描述每个段的相关内容
		0~1字节：段界线1
		2~4字节：段基址的低位
		5~6字节：段属性
			5_0~5_3——TYPE属性：4位可表示16种状态
			5_4——S属性：指明是数据段/代码段（S=1）还是系统段/门描述段（S=0）
			5_5~5_6——DPL属性：描述特权级，可取0、1、2、3，值越小特权级越大
			5_7——P属性：取1 表示段在内存中存在，0表示不存在
			6_0~6_3——段界限2
			6_4——AVL保留位，被系统软件使用的位
			6_5——恒取0
			6_6——D/B属性：
			6_7——G属性
		7字节：段基址2

		注：从以上的分段很难理解为什么要界限和地址要分开存放，但是就像计算机中很多不让人理解的设计一样，都是历史惹的祸——即以前设计时很多问题没想到（容量会加大，地址位会增加等），仅仅为了实现而实现，等到问题出现需要改进时，发现前面的成果太多，推掉重做可能性不大，只能采用简单方法更改以保证向下兼容


	gdtr寄存器（全局描述符表寄存器）：
		共6个字节，前两个字节用来存储全局描述符表界限，后四个字节用来存储全局描述符表的起始位置

	A20地址线：
		8086中用[段：偏移]表示实际地址，而这个方式理想状态下最大可表示[FFFF：FFFF]，即10FFEFh，这个地址超过8086最大寻址空间1M，所以在设计8086时采用回卷寻址的设计办法，即超过的部分重新从0开始；但到了80286，寻址空间变成了2^24=16M，所以不需要采用回卷寻址了，但是为保持向下兼容性，80286结构不可能重新设计，因此IBM提出方法——使用8042键盘控制器控制第20个地址位（即A20地址线），再根据A20的状态决定是否采用循环地址，打开（高电平）则不进行回卷寻址，开机实模式下默认不打开，所以须由软件实现打开

	cr0寄存器：32位寄存器，上面包含多个状态标志位
		0位——PE位，0表示实模式，1表示保护模式
		31位——PG位，0表示分页机制无效，1表示有效

	段选择子：16位的描述符
		0~1位——RPL位
		2位——TI位
		3~15位：描述段的索引，即表示第几个段（忽略空段），共可以存储2^13=8192个段
		注：因为每个段描述符刚好是8个字节，所以当后3位都为0时，段选择子此时就相当于当前指向的段对应的段描述符地址（相当于第一个段描述符的偏移地址）
			0000 0000 0000 0000：明显对应第1个段描述符，但一般把第一个段描述符设置为空（所以设置为空的原因就是为了让3~15位的值和有意义段的段数刚好吻合）
			0000 0000 0000 1000：表示第一个非空段，3~15位值刚好为1，而整个值刚好为8——第一个非空段相对于段描述符表起始位置的偏移地址

5、局部描述符表（LDT）

6、分页机制
	一个页在物理存储中固定大小，8086中是4KB，奔腾中是2MB或4MB
	cr0~cr4
	cr3
	PDE（页目录表项）：每个页目录表项4个字节，存储一个页二级表的起始地址
	PTE（页二级表项）：一个页二级表包含1024个页二级表项，每个页目录表项4个字节，存储一个物理页的起始地址
