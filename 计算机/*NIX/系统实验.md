```
进程相关
  Ubuntu 12.04一般优先保证父进程的运行pid_t：新的类型，声明在sys/types.h中
	getpgrp：声明在unistd.h的函数，返回当前的进程组（根进程）
	memset(*str, n, lenSize)：将str指向的内存中，lenSize字节数据设为n，多少字节设为一个n由str决定，或者用sizeof(type)*num


	pid_t wait(int *state)：当前进程阻塞，然后寻找僵尸进程（在父进程未结束时先结束），若找到，消灭僵尸进程并停止阻塞，若未找到，则继续阻塞；（父进程结束后子进程未结束就称为init进程的子进程），成功则返回消灭的进程ID，不成功则返回-1

	pid_t waitpid( pid_t pid , int *state , int option)：sys/types.h
		pid>0，等待进程ID等于pid的子进程结束；pid=0，等待统一进程组中的任意进程；pid<-1，等待进程组ID的绝对值等于pid的进程组中任一子进程结束；pid=-1，等待任何一个子进程结束，此时的作用完全同wait（其实wait就是waitpid(-1,wait_stat,0)）

		state是用于保存进程死掉时候样子的指针，若我们不需要知道进程死时候的样子，就使用参数NULL

		option=0，强制等待进程结束；option=WNOHANG，不管结束与否都不再等待；option=WUNTRACED不常用

		一般返回等待进程的ID号；当option为WNOHANG时，且检测到没有已经结束的子进程，则返回0；若调用出错，则返回-1

	sleep(int second)：让当前进程休眠second秒时间

	exit(int state)：结束当前的进程，state=1时非正常结束（生成进程、生成文件指针不成功等），state=0正常结束

	pid_t fork(int *state)：新建子进程，同时返回给父进程和新建的子进程两个值，若生成成功，则返回给父进程一个大于0的数，返回给新建的子进程0；若生成成功，则返回给父进程和新建的子进程均为-1；生成的子进程完全“复制”父进程的代码（不进行物理拷贝），同时复制数据和堆栈（物理复制），注意，这其中包括缓冲区的数据；



	exec函数族：不用时子进程完全复制父进程代码，而exec函数族则使用外部程序作为子进程代码，使用后原代码不能再使用




匿名管道：
	仅能在亲缘关系的进程间通信（父子，兄弟）；半双工——仅能单向流动；主存特殊文件，大小为一个页面；传送无格式字节流

	int pipe(int fd[2])（fd为标识符，可变，可以通过猜想fd[]中应该存的是地址，或者fd[0]/fd[1]本身就代表地址）：调用成功时，返回0，失败返回-1；成功时，fd[0]可代表管段读取端，fd[1]代表管道写端，匿名管道支持一般文件的I/O操作，如close(),read(),write()

	close(fd[0])/close(fd[1])：关闭读端/写端

	int read(fd[0],char *str,int lenSize)：读取读端fd[0]的lenSize长度数据到str指向的内存
		成功返回0，不成功返回-1

	int write(fd[1],char *str,int lenSize)：将str指向内存的lenSize长度数据写到写端fd[1]
		成功返回0，不成功返回-1


命名管道：
	克服匿名管道的亲缘限制；存在系统中的文件绝对路径

	int mkfifo(const char *pathname, mode_t mode)：新建命名管道，第一个参数（新建命名管道文件的标识符）的写法就是文件地址的字符串，mode则规定一系列的参数（），成功返回0，失败返回-1，若文件已经存在，则errno错误值为EEXIST，管道文件支持一系列的文件I/O操作，如close(),read(),write()


	fd=int open(const char *pathname, option, )：
		命名管道文件需要进行打开操作，返回值同时做文件开启对应通道的标识符
		option：O_WRONLY 只写  O_RDONLY 只读  |O_NONBLLOCK 可选修饰符，加表示没有阻塞标志

		仅请求读打开
			已经有写进程打开管道文件：成功，返回0
			没有写进程打开管道文件（拥有阻塞标志）：进入阻塞状态，直到有写进程打开管道
			没有写进程打开管道文件（无阻塞标志）：成功，返回0
		仅请求写打开
			已经有读进程进行打开操作：成功，返回0
			没有读进程进行打开操作（拥有阻塞状态）：进入阻塞状态，直到有读进程打开管道
			没有读进程进行打开操作（无阻塞标志）：错误，返回-1，errno=EAGAIN


	read(fd,char *str,int lenSize)：
		有阻塞标志
			管道无数据或数据不够：进入阻塞状态，直到两个阻塞条件都消除
			其它进程在读数据：进入阻塞状态，直到两个阻塞条件都消除
			管道有数据：成功，返回0
		无阻塞标志
			管道无数据或数据不够：错误，返回-1，errno=EAGAIN
			其它进程在读数据：错误，返回-1，errno=EAGAIN
			管道有数据：成功，返回0

		注意：读的阻塞仅仅对第一个使用的操作有效 ，当第一个被阻塞并被唤醒后，其它的都不在阻塞，即均返回0


	write(fd,char *str,int lenSize)：
		有阻塞标志
			请求写的数据量不大于管道缓冲区最大容量
				请求写的数据量不大于缓冲区剩余容量：一次性通过缓冲区写入
				请求写的数据量大于缓冲区剩余容量：休眠，直到不大于时一次性写入
			请求写的数据量大于管道缓冲区最大容量：只要管道缓冲区有空闲就写
		无阻塞标志
			请求写的数据量不大于管道缓冲区最大容量
				请求写的数据量不大于缓冲区剩余容量：一次性通过缓冲区写入
				请求写的数据量大于缓冲区剩余容量：错误，返回-1，errno=EAGAIN
			请求写的数据量大于管道缓冲区最大容量：只要管道缓冲区有空闲就写

	close(const char *pathname)：关闭管道文件
	
	unlink(const char *pathname)：删除管道文件










关于在Shell中运行多进程程序的问题：
	在Shell中运行程序1，程序1已经作为Shell的子程序，程序1中再产生子程序2，则程序2为Shell的孙程序，这时候若程序1在程序2之前结束，则程序2的结果还没输出，Shell的提示就会先输出（Shell只会等待当前的子程序结束，而不会等待孙程序）
```
