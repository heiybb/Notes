一、树的形式化定义：
  1、只有根节点没有双亲节点（也称父节点），其它节点均有唯一的双亲节点
	2、除叶子节点外，每个节点有一个或多个孩子节点
	3、树中各节点之间的父子关系不能形成环，一棵固定的树只有唯一的根节点
	4、节点数为0时称为空树
	
	
二、树的基本名词解释：
	1、节点的度：某节点的度等于该节点子树的个数，也等于该节点子节点的个数
	2、树的度：所有节点中最大的度称为该树的度
	3、根节点：
		这个节点并不是可形式化定义的，只能由设计者人为给定，但一棵固定的树只有唯一的根节点。比如有一棵只有两个节点的树，以树形图表示时好像谁都可以作为父节点，但在给定树的同时须给定根节点，则当以两个节点分别表示根节点时就代表两棵树。
	4、分支节点：
		度不为0的节点，也称非终端节点；可以在分支节点前加度数做修饰词，如单/双/三分支节点
	5、叶子节点：度为0的节点，也称终端节点
	6、子节点（相对于确定节点而言）：某节点的直接后继节点
	7、父节点（相对于确定节点而言）：某节点的直接前缀节点，也称双亲节点
	8、兄弟节点（相对于确定节点而言）：两个节点的直接前缀节点是一个节点
	9、节点的层次（相对于根节点而言）：根节点为第一层，每个子节点的层次为父节点层次+1
	10、树的高度：即最大的层次值，也称为深度
	11、祖先节点（相对于确定节点而言）：从根节点到该节点路径上的所有节点（除本身以外）
	12、子孙节点（相对于确定节点而言）：
		以该节点为根节点的子树上的所有节点（除本身以外）
	13、堂兄弟节点（相对于确定节点而言）：两节点的层次相同
	14、路径：
		两节点通过父子关系达成的连接，由于父子关系是有向的——即只能从父节点和子节点，所以要想从节点A到达节点B，节点A必须是节点B的祖先节点，而且这个路径只有一条
	15、路径长度：路径上的分支数目，形象讲就是图中路径的边个数
	16、树的路径长度：从树根到每个节点的路径长度之和
	17、带权路径长度：路径长度*权值
	18、树的带权路径长度（WPL）：从树根到每个叶子节点的带权路径长度之和
	19、有序树：对于任意节点的子树是有从左到右的排序关系的
	20、无序树：没有有序树的要求
	21、森林：
		将互不相交的多棵树作为整体就形成了森林，森林与树的转换只需要一步，删除树中任意一个分支节点就可以成为成为森林；在森林中加入一个节点，并分别从每棵树中选一个节点与加入的节点形成父子关系就可以形成一棵树
	22、二叉树的5种基本状态：
		空树、单节点、父节点和左节点、父节点和右节点、父节点和左右节点
	
	
	
三、树的逻辑表示方法：
	1、树形表示法
	2、文氏图表示法
	3、凹入表示法
	4、括号表示法
	
	
四、二叉树的存储形式
	顺序存储结构：
		按从高层次到底层次，从左到右的的顺序将节点存储在一组连续的地址中，如果对于“应该在对应完全二叉树中存在的节点”不在“当前的二叉树”中，则对应的线性地址位存0（这个显然有弊端，比如节点数据刚好为0则需变换标志数据，而当树为一般树时，会浪费大量空间，所以顺序存储结构最好存储完全二叉树）
	链式存储结构：
		此时的节点设置为数据域和左右指针（分别指向左右子节点）
		在n个节点的树中含有n+1个空指针

	
四、特殊二叉树
	1、full/strict二叉树：
		每个节点有0个或2个子节点（严蔚敏教程中没有这个，而严蔚敏教程中对“满二叉树”的定义同下面的perfect二叉树）
	2、perfect二叉树：
		高度为n且节点数为2^n-1的二叉树（严蔚敏的教材中将这个翻译为满二叉树）
	3、完全二叉树：
		高度为n的二叉树，第k层的节点数为2^(k-1)[1<=k<=n-1]，即除了最后一层，所有层次都是完全的，而且最后一层的叶子节点必须从左向右填入。
	4、无穷完全二叉树：即高度无穷，对应节点无穷
	5、平衡二叉树（默认指经典平衡二叉树）：
		对任意节点，其左右子树的高度差不超过1，也称AVL树（注意）
	6、退化二叉树：对每个节点，只有0个或1个子节点，即相当于线性表，也称单支树
	7、遍历二叉树：见第七点
	8、线索二叉树：见第八点
	9、最优二叉树（赫夫曼树）：见第十点
	10、二叉排序树：
		满足一下三条的树或者空树为二叉排序树：
			1). 左子树上所有结点的值均小于它的根节点的值
			2). 右子树上所有结点的值均小于它的根节点的值
			3). 左右字数分别为二叉排序树



	
	
		
	
	
	
六、树的性质
	1、二叉树的第i层上之多有2^(i-1)个结点
	2、深度为k的二叉树至多有2^k-1个结点
	3、对一棵二叉树，若其叶子结点数为n_0，度为2的结点数为n_2，则有n_0=n_2+1
	4、具有n个结点的完全二叉树的深度为log2n+1
	5、如果对一棵有n个结点的完全二叉树的结点按层次从左往右编号，则对i序号结点，有以下性质
		1). 如果i=1，则为根节点；i>1，则其双亲结点序号为[i/2]——这里表示向下取整
		2). 如果2i>n，则结点i无左孩子，否则其左孩子结点序号为2i
		3). 如果2i+1>n，则结点i无右孩子，否则其右孩子结点序号为2i+1
	6、链式存储中，二叉树的结点个数为n，则空指针恒为n+1，非空指针恒为n-1
	7、树的结点数为n，度数即为n-1
	8、唯一的确定一棵二叉树可采用以下方案
		1). 中序+后序
		2). 中序+前序
		3). 中序+层序
		注：原因是前序、后序、前序都提供的是根结点的信息，而只有中序提供的是左右子树的信息（在知道根节点的情况下）
	
	
七、二叉树的遍历（遍历二叉树）
	限定从左向右遍历的三种遍历方式，层次遍历没有特殊性
	1、先根遍历：先访问根节点，然后从左向右依次访问每一棵子树，也称先序遍历
	2、中根遍历：先访问左子树，再访问根节点，最后访问右子树，也称中序遍历
	3、后根遍历：先访问左子树，再访问右子树，最后访问根节点，也称后序遍历
	4、层次遍历：先从左往右访问第一层节点，再从左往右访问第二层节点，依此类推



八、线索二叉树
	当二叉树采用链式存储的时候，根据性质6总是有很多空指针被浪费，此时就构造线索二叉树利用这些空指针
	
	构造：
		1、对一个已成形的二叉树，转换为中序遍历（显然这是个非线性转线性的过程）
		2、对二叉树的空指针进行赋值，若该空指针为左指针，则指向其中序前驱；若为右指针，则指向其中序后继；对没有前驱或后继的时候指向NULL。
		3、所有的指针被填满后，为了区别这些指针是指向左/右孩子还是中序前驱/后继，则在每个节点加上两个标志位——分别标识左右指针的指向状态，1表示指向中序前驱/后继，0表示指向左/右孩子
		
	遍历：
		1、对构造好的线索二叉树，指示一个起点，不断沿着其中序后继遍历，就能得到中序结果（若二叉树的原中序遍历为1、2、3，对构造后的线索二叉树制定起点为2，则得到的遍历结果为2、3）
		2、当当前结点没有中序后缀——即其右指针指向右孩子——该结点为非叶子节点，按中序遍历的思想，此时就该找当前节点的右子树的第一个遍历结点——即右子树最左下结点。遍历方法为以当前结点的右孩子为根节点，不断向下找左孩子，直到找不到就是下一个遍历结点

九、树和森林
	树的链式存储表示法
		1、双亲表示法
			按顺序表的形式存储——见下面树的定义，将点按照层次从左往右编号（从0起），但是不同于顺序树的编号方式——即不填充为完全二叉树，每个节点记录自己的数据data和双亲结点的编号parent，以下为定义
			
			#define MAX_TREE_SIZE  
			typedef struct PTNode{ //结点的定义
				TElemType data;
				int parent;
			}PTNode;
			typedef struct { //树的定义
				PTNode nodes[MAX_TREE_SIZE];
				int r,n;
			}PTree;
		2、孩子表示法
			大体上依旧是按照顺序表的形式存储，只是顺序表中parent变为firstchild，而firstchild存储该结点孩子链表的头指针，这个可以类比图存储中的邻接表
		
			typedef struct CTNode{ //定义链表结点（用于创建孩子结点）
				int child;
				struct CTNode *next;
			}*ChildPtr;
			typedef struct { //定义每个结点
				TElemType data;    //本结点的数据
				ChildPtr firstchild;  //头指针，即指向本结点的第一个孩子结点
			}CTBox;
			typedef struct { //定义树
				CTBox nodes[MAX_TREE_SIZE];  //头指针数组
				int r,n;
			}CTree;
				
		3、孩子兄弟表示法
			每个节点有三个域，左指针域指向其左孩子，右指针域指向其右兄弟，数据域存储自己的数据，这样任何一棵树都可以唯一转换为一棵二叉树
		
	树和二叉树的转换
		任何一棵树通过孩子兄弟表示法可唯一变化为一棵二叉树
		
	森林转化为二叉树的规则
		森林F={T1, T2, T3, …, Tn}转换为树B，以T1的根节点为B的根节点，T1除去根节点后的森林再按此规则构成B的左子树，而{T2, T3, …, Tn}按此规则构成B的右子树
		
	二叉树转化为森林的规则
		将森林转换为二叉树的规则逆转即可


十、最优二叉树及赫夫曼编码
	最优二叉树（赫夫曼树）
		对n个权值构成的WPL最小的一颗树称为最优二叉树（赫夫曼树）
		
	最优二叉树的构造及意义
		意义：在分类上可以基于最少的比较次数
		
		根据给定的n个权值为{w_1~w_n}的节点构造最优二叉树
			1、构造集合F，F中包含n棵单节点树{T_1~T_n}，对应包含的节点为{w_1~w_n}
			2、在F中选取任意两棵根节点权值最小的树作为左右子树，然后将两根节点的权值相加作为新根节点的权值，接着在F中删除两棵树，同时在F中添加新形成的树
			3、F中只有一颗树的时候，这棵树就是最有二叉树，否则继续操作2
			
	赫夫曼编码
		在传输数据的时候，由于总是只有0和1两种基本状态，所以计算机的任何数据处理前都需要经过译码，而如何译码则根据编码的方式来决定，不同的编码方式决定了相同原意下的存储数据，为了使存储数据尽量小，这其中就会用到赫夫曼编码
		
		假设传输数据为ASCII码表示的内容，那么最常见的就是直接用每8位表示一个字符，此时就会浪费大量的空间（我们以0的数量表示浪费的内存），那么现在就可以采用删除其中一些占位来编码，但这也会导致其它问题，就是多少个占位来表示一个字符，这时候就可以引入前缀编码（即任意字符的编码都不能是其它字符编码的前缀），而赫夫曼编码就是找到最短的前缀编码方式（当然是针对特定问题）
